(in-package #:coalton-impl/codegen)

(deftype interaction-mode ()
  `(member :development :release))
(declaim (type interaction-mode *interaction-mode*))


;; *interaction-mode* determines how redefinable code generated by Coalton is.
;;
;; In development mode Coalton turns all declare-type forms into CLOS
;; objects to support a repl based workflow.
;;
;; In release mode Coalton compiles declare-type forms into frozen
;; structs or even more optimal layouts which may not support
;; redefinition.
;;
;; This variable *must* be set before the standard library is loaded.
;; Coalton defaults to development mode but switches to release mode
;; if the environment variable COALTON_ENV is set to release.
(defvar *interaction-mode* :development)

(defun compile-type-definition (def env)
  (let ((package (symbol-package (type-definition-name def))))

    (cond
      ((type-definition-compressed-type def)
       (loop :for constructor :in (type-definition-constructors def)
             :collect
             `(coalton-impl::define-global-lexical
                  ,(constructor-entry-name constructor)
                  ',(constructor-entry-compressed-repr constructor))))

      ((type-definition-newtype def)
       (let ((constructor (first (type-definition-constructors def))))
         `((declaim (inline ,(constructor-entry-name constructor)))
           (defun ,(constructor-entry-name constructor) (x) x)
           (coalton-impl::define-global-lexical
               ,(constructor-entry-name constructor)
               (coalton-impl/codegen::F1 #',(constructor-entry-name constructor))))))

      ((eql :development *interaction-mode*)
       `((defclass ,(type-definition-name def) ()
           ())

         ,@(loop
             :for constructor :in (type-definition-constructors def)
             :for classname := (constructor-entry-classname constructor)
             :for slot-types := (mapcar #'coalton-impl/typechecker::fresh-inst (constructor-entry-arguments constructor))
             :for slot-names := (ctor-make-slot-names (length slot-types) package)
             :append
             `((defclass ,classname (,(type-definition-name def))
                 ,(ctor-make-class-slots slot-names slot-types env)))

             :append
             `((declaim (inline ,(constructor-entry-name constructor)))
               (defun ,(constructor-entry-name constructor) ,slot-names
                    (make-instance ',classname
                                   ,@(mapcan (lambda (x) `(',x ,x))
                                             slot-names))))

             :collect (cond
                        ((zerop (constructor-entry-arity constructor))
                         `(defmethod print-object ((self ,classname) stream)
                            (declare (type stream stream)
                                     (type ,classname self)
                                     (values ,classname))
                            (format stream "#.~s" ',(constructor-entry-name constructor))
                            self))
                        (t
                         `(defmethod print-object ((self ,classname) stream)
                            (declare (type stream stream)
                                     (type ,classname self)
                                     (values ,classname))
                            (format stream "#.(~s~{ ~s~})"
                                    ',(constructor-entry-name constructor)
                                    (list ,@(mapcar (lambda (slot) `(slot-value self ',slot)) slot-names)))
                            self)))

             :append (cond
                       ((zerop (constructor-entry-arity constructor))
                        `((coalton-impl::define-global-lexical
                              ,(constructor-entry-name constructor)
                              (,(constructor-entry-name constructor)))))
                       (t
                        (let* ((arity (length slot-names))
                               (entry (construct-function-entry
                                       `#',(constructor-entry-name constructor)
                                       arity)))
                          `((coalton-impl::define-global-lexical
                                ,(constructor-entry-name constructor)
                              ,entry))))))))

      (t
       `((defstruct (,(type-definition-name def)
                     (:constructor nil)
                     (:predicate nil)
                     (:copier nil)))

         ,@(loop
             :for constructor :in (type-definition-constructors def)
             :for classname := (constructor-entry-classname constructor)
             :for slot-types := (mapcar #'coalton-impl/typechecker::fresh-inst (constructor-entry-arguments constructor))
             :for slot-names := (ctor-make-slot-names (length slot-types) package)
             :append
             `((declaim (inline ,(constructor-entry-name constructor)))
               (defstruct (,classname
                           (:include ,(type-definition-name def))
                           (:constructor ,(constructor-entry-name constructor) ,slot-names)
                           (:predicate nil)
                           (:copier nil))
                 ,@(ctor-make-slots slot-names slot-types env))
               #+sbcl (declaim (sb-ext:freeze-type ,classname)))
             :collect (cond
                        ((zerop (constructor-entry-arity constructor))
                         `(defmethod print-object ((self ,classname) stream)
                            (declare (type stream stream)
                                     (type ,classname self)
                                     (values ,classname))
                            (format stream "#.~s" ',(constructor-entry-name constructor))
                            self))
                        (t
                         `(defmethod print-object ((self ,classname) stream)
                            (declare (type stream stream)
                                     (type ,classname self)
                                     (values ,classname))
                            (format stream "#.(~s~{ ~s~})"
                                    ',(constructor-entry-name constructor)
                                    (list ,@(mapcar (lambda (slot) `(slot-value self ',slot)) slot-names)))
                            self)))

             :append (cond
                       ((zerop (constructor-entry-arity constructor))
                        `((coalton-impl::define-global-lexical
                              ,(constructor-entry-name constructor)
                              (,(constructor-entry-name constructor)))))
                       (t
                        (let* ((arity (length slot-names))
                               (entry (construct-function-entry
                                       `#',(constructor-entry-name constructor)
                                       arity)))
                          `((coalton-impl::define-global-lexical
                                ,(constructor-entry-name constructor)
                              ,entry))))))
         #+sbcl
         (declaim (sb-ext:freeze-type ,(type-definition-name def))))))))

(defun ctor-make-slot-names (count package)
  (loop :for i :below count
        :collect (alexandria:format-symbol package "_~D" i)))

(defun ctor-make-slot (name type env)
  `(,name (error "") :type ,(lisp-type type env) :read-only t))

(defun ctor-make-slots (slot-names slot-types env)
  (loop :for slot-name :in slot-names
        :for slot-type :in slot-types
        :collect (ctor-make-slot slot-name slot-type env)))

(defun ctor-make-class-slot (name type env)
  `(,name :initform (error "")
          :initarg ,name
          :type ,(lisp-type type env)))

(defun ctor-make-class-slots (slot-names slot-types env)
  (loop :for slot-name :in slot-names
        :for slot-type :in slot-types
        :collect (ctor-make-class-slot slot-name slot-type env)))
